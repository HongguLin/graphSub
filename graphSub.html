<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-COMPATIBLE" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>graphSub</title>
    <title>Animating Changes in Force Diagram</title>
    <script src="http://d3js.org/d3.v3.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <style>
        .link {
            stroke: #2E2E2E;
            stroke-width: 2px;
        }

        .node {
            stroke: #fff;
            stroke-width: 2px;
        }

        .textClass {
            stroke: #23232;
            font-family: "Arial", "Liberation Sans", Arial, Helvetica, sans-serif;
            font-weight: normal;

            stroke-width: .1;
            font-size: 1px;

        }

        #licensing {
            fill: green;
        }

        .link.licensing {
            stroke: green;
        }
    </style>
</head>
<body>
<script>
    /*  Features
        clicable text labels
        no overlap of labels- http://bl.ocks.org/MoritzStefaner/1377729
        arrows - http://bl.ocks.org/mbostock/1153292
    */

    // add a method conditionaly
    if (!('xpush' in Array.prototype)) {
        // push value to array only if not already present
        Array.prototype.xpush = function(value){
            if(this.indexOf(value) === -1){
                this.push(value);
            };
            return this
        };
    }
    
    d3.json("data/miserables.json", function(error, graph) {
        if (error) throw error;
        
        function chart(elementName) {

            var width = function(value) {
                if (!arguments.length) return width;
                width = value;
                return chart; // enable chaining
            };

            var height = function(value) {
                if (!arguments.length) return height;
                height = value;
                return chart; // enable chaining
            };

            var resize = function() {
                //var svg = d3.select(elementName).append("svg");
                width = window.innerWidth, height = window.innerHeight;
                vis.attr("width", width).attr("height", height);
                force.size([width, height]).resume();
            }

            // add nodes to the layout
            var addNode = function(node){
                nodes.push(node);                
            };

            // add link to the layout
            var addLink = function(source, target, value){
                var link = {"source": findNode(source), "target": findNode(target), "value": value};
                subNetLinks.push(link);
            };

            // look for the node in the d3 layout
            var findNode = function(name) {
                for (var i in subNetNodes) {
                    if (subNetNodes[i]["name"] === name) return subNetNodes[i];
                };
            };

            // remove all links form the layout
            var removeAllLinks = function(linkArray) {
                linkArray.splice(0, linkArray.length);
                //update();
            };

            // remove all node from the layout
            var removeAllNodes = function(nodeArray) {
                nodeArray.splice(0, nodeArray.length);
                //update();
            };

            var findNodeIndex = function(name, nodes) {
                for (var i = 0; i < nodes.length; i++) {
                    if (nodes[i].name == name) {
                        return i;
                    }
                };
            };

            var subNet = function(currentIndex, hops){
                // links stored as JSON objects, easy to compare
                // operates on the data loaded from the JSON
                // extract subnet around 'currentIndex' with all nodes up to 2 'hops' steps away.

                var n = graph.nodes[currentIndex];
                subNetNodes.xpush(n);

                if (hops === 0) {
                    return;
                };

                for (var i = 0; i < graph.links.length; i++) {

                    if (currentIndex === graph.links[i].source) {
                        linkStrings.xpush(JSON.stringify(graph.links[i]));
                        subNet(graph.links[i].target, hops - 1)
                    };
                    if (currentIndex === graph.links[i].target) {
                        linkStrings.xpush(JSON.stringify(graph.links[i]));
                        subNet(graph.links[i].source, hops - 1)
                    };
                };                
            };

            var createAnchors = function(){
                // create nodes and links for the labels
                // see http://bit.ly/1eDQDS5
                for (var i = 0; i < subNetNodes.length; i++) {
                    // one node is anchor to the force1 node
                    var n = {
                        label : subNetNodes[i]
                    };

                    labelAnchors.push({
                        node : n
                    });
                    labelAnchors.push({
                        node : n
                    });
                };
            };

            var createAnchorLinks = function(){
                for (var i = 0; i < subNetNodes.length; i++) {
                    // join nodes in pairs

                    labelAnchorLinks.push({
                        source : i * 2,
                        target : i * 2 + 1,
                        weight : 1
                    });
                };
            };

            var clickHandler = function(d, i){
                //console.log(d);
                var nodeName;

                if (d.hasOwnProperty('node')) {
                    nodeName = d.node.label.name;
                } else {
                    nodeName = d.name;
                };
                // graph refreshed onces after nodes is added then after links
                // prevents wild variations in graph render.
                
                linkStrings = []; // var to ensure links no repeated
                
                removeAllNodes(subNetNodes); // clears force.nodes()
                removeAllLinks(subNetLinks); // clears force.links()
                
                removeAllNodes(labelAnchors);
                removeAllLinks(labelAnchorLinks);
                
                var link,
                    source,
                    target;

                // first the nodes and anchors
                // extract subnet around 'd' with all nodes up to 2 hops away
                subNet(findNodeIndex(nodeName, graph.nodes), 2);
                createAnchors();
                
                update();
                

                // now the links and anchor links
                // add links incrementaly
                for (var i = 0; i < linkStrings.length; i++) {
                    link = JSON.parse(linkStrings[i]);

                    source = graph.nodes[link.source];
                    target = graph.nodes[link.target];
                    addLink(source.name, target.name, 2);
                      
                };

                createAnchorLinks();
                
                update();
                console.log('clickHandler done')
            };

            d3.select(window).on("resize", resize)

            var width = 1000, // default width
                height = 500; // default height
            
            var color = d3.scale.category10(),
                force = d3.layout.force(),
                force2 = d3.layout.force(); // labelAnchors/Links
            
            // references to the force datums
            var subNetNodes = force.nodes(),
                subNetLinks = force.links();
            
            // force2 nodes and labels
            var linkStrings = [],
                labelAnchors = force2.nodes(),
                labelAnchorLinks = force2.links();
            
            var vis,
                runOnceFlag = true;

            vis = d3.select(elementName)
                    .append("svg:svg")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("id", "svg")
                    .attr("pointer-events", "all")
                    .attr("viewBox", "0 0 " + 1000 + " " + 500)
                    .attr("perserveAspectRatio", "xMinYMid")
                    .append('svg:g');

            // Per-type markers, as they don't inherit styles.
            vis.insert("defs")
                .selectAll("marker")
                .data(["suit", "licensing", "resolved"])
                .enter()
                    .append("marker")
                        .attr("id", function(d) { return d; })
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 15)
                        .attr("refY", -0.5)
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto")
                        .append("path")
                            .attr("d", "M0,-5L10,0L0,5");
                    

            var update = function() {

                // join
                var link = vis.selectAll("line")
                        .data(subNetLinks, function (d) {
                            //console.log('update', typeof(d.source), d);
                            if (typeof(d.source) === 'number') {
                                return subNetNodes[d.source].name + "-" + subNetNodes[d.target].name;
                            }else{
                                return d.source.name + "-" + d.target.name;
                            };
                        });
                
                // enter
                link.enter().insert("line", "g")
                        .transition()   
                        .delay(function (d, i) {
                            return 3000 + i*100;
                        })
                        .attr("id", function (d) {
                            return d.source.name + "-" + d.target
                            .name;
                        })
                        .attr("stroke-width", function (d) {
                            return d.value / 10;
                        })
                        .attr("class", "link")
                        .attr("marker-end", "url(#suit)");
                
                // update
                link.append("title")
                        .text(function (d) {
                            return d.value;
                        });
                
                // exit
                link.exit().remove();

                // join
                var node = vis.selectAll("g.node")
                        .data(subNetNodes, function (d) {
                            return d.name;
                        });

                // enter
                var nodeEnter = node.enter()
                        .append("g")
                        .attr("class", "node")
                        .attr("opacity", 0)
                        .call(force.drag);

                // enter
                nodeEnter
                        .on('click', clickHandler)

                // enter
                nodeEnter
                        .append("svg:circle")
                        .attr("r", 0)
                        .attr("id", function (d) {
                            return "Node;" + d.name;
                        })
                        .attr("class", "nodeStrokeClass")
                        .attr("fill", function(d) { return color(d.group); });

                // exit
                node.exit().remove();

                // ###
                
                // join
                var anchorLink = vis.selectAll("line.anchorLink")
                                    .data(labelAnchorLinks);//.enter().append("svg:line").attr("class", "anchorLink").style("stroke", "#999");

                // join
                var anchorNode = vis.selectAll("g.anchorNode")
                                    .data(labelAnchors, function(d, i){
                                        return d.node.label.name + i;
                                    });

                // enter
                var anchorNodeEnter =  anchorNode
                                        .enter()
                                        .append("svg:g")
                                        .attr("class", "anchorNode");

                anchorNodeEnter
                    .on('click', clickHandler)
                
                // enter
                anchorNodeEnter
                    .append("svg:circle")
                    .attr("r", 0)
                    .style("fill", "#FFF");

                // enter
                anchorNodeEnter
                    .append("svg:text")
                    .text(function(d, i) {
                        return i % 2 == 0 ? "" : d.node.label.name
                    })
                    .style("fill", "#555")
                    .style("font-family", "Arial")
                    .style("font-size", 12);

                // exit
                anchorNode.exit().remove();

                // Restart the force layout.
                force
                    .size([width, height])
                    .charge(-3000)
                    .gravity(1)
                    .linkDistance(50)
                    .start();                

                // restart the labels force layout
                force2
                    .size([width, height])
                    .gravity(0)
                    .linkDistance(0)
                    .linkStrength(8)
                    .charge(-100)
                    .start();

                //console.log('selection', anchorNode);
                //console.log('force datum', force2.nodes());

                var updateLink = function() {
                    this.attr("x1", function(d) {
                        return d.source.x;
                    }).attr("y1", function(d) {
                        return d.source.y;
                    }).attr("x2", function(d) {
                        return d.target.x;
                    }).attr("y2", function(d) {
                        return d.target.y;
                    });
                }

                var updateNode = function() {
                    this.attr("transform", function(d) {
                        //console.log('line 398',d.x, d.y);
                        return "translate(" + d.x + "," + d.y + ")";
                    });
                }

                force.on("tick", function() {
                    force2.start();
                                  
                    //---------
                    node.call(updateNode);
                    
                    anchorNode.each(function(d, i) {
                        
                        if(i % 2 == 0) {
                            d.x = d.node.label.x;
                            d.y = d.node.label.y;
                        } else {
                            // get the bounding box
                            var b = this.childNodes[1].getBBox();

                            var diffX = d.x - d.node.label.x;
                            var diffY = d.y - d.node.label.y;

                            var dist = Math.sqrt(diffX * diffX + diffY * diffY);

                            var shiftX = b.width * (diffX - dist) / (dist * 2);
                            shiftX = Math.max(-b.width, Math.min(0, shiftX));
                            
                            var shiftY = 5;
                            
                            // move the label of the current anchor
                            this.childNodes[1].setAttribute("transform", "translate(" + shiftX + "," + shiftY + ")");
                        }
                    });
                    anchorNode.call(updateNode);
                    //---------
                    link.call(updateLink);
                    anchorLink.call(updateLink);
                });
            ///                
            };

            if (runOnceFlag) {
                // initialise the display
                subNet(0, 1)
                clickHandler(subNetNodes[0]);
                runOnceFlag = false;
            };
        };
        ///
        chart('body');
    });
</script>
</body>
</html>